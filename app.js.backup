/**
 * @file app.js
 * @description Main application logic for the Non-Profit Fund Accounting System.
 * This script handles data fetching, UI rendering, navigation, and user interactions.
 */

// Application State
const appState = {
    entities: [],
    accounts: [],
    funds: [],
    journalEntries: [],
    users: [],
    organizationSettings: {},
    customReportDefinitions: [],
    selectedEntityId: null,
    isConsolidatedView: false,
    currentPage: 'dashboard',
    currentTab: 'settings-users', // Default tab for settings page
    dbConnected: false,
    entityTypes: {
        ROOT: 'root',
        ENTITY: 'entity',
        FUND: 'fund'
    }
};

// Utility Functions
function formatCurrency(amount) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2
    }).format(amount || 0);
}

function formatDate(dateString) {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    }).format(date);
}

function formatPercentage(value, total) {
    if (!total) return '0.0%';
    return ((value / total) * 100).toFixed(1) + '%';
}

// API Functions
async function fetchData(endpoint) {
    try {
        console.log(`Fetching data from /api/${endpoint}...`);
        const response = await fetch(`/api/${endpoint}`);
        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }
        const data = await response.json();
        console.log(`Received ${data.length} items from /api/${endpoint}`);
        return data;
    } catch (error) {
        console.error(`Error fetching ${endpoint}:`, error);
        return [];
    }
}

async function saveData(endpoint, data, method = 'POST') {
    try {
        const response = await fetch(`/api/${endpoint}`, {
            method,
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error(`Error saving to ${endpoint}:`, error);
        throw error;
    }
}

// Database Connection Check
async function checkDatabaseConnection() {
    try {
        const dbStatusIndicator = document.getElementById('db-status-indicator');
        
        // Try to fetch entities as a connection test
        const response = await fetch('/api/entities');
        if (response.ok) {
            if (dbStatusIndicator) {
                dbStatusIndicator.textContent = 'DB Connected';
                dbStatusIndicator.classList.remove('offline');
                dbStatusIndicator.classList.add('online');
            }
            appState.dbConnected = true;
            return true;
        } else {
            if (dbStatusIndicator) {
                dbStatusIndicator.textContent = 'DB Offline';
                dbStatusIndicator.classList.remove('online');
                dbStatusIndicator.classList.add('offline');
            }
            appState.dbConnected = false;
            return false;
        }
    } catch (error) {
        console.error('Database connection check error:', error);
        const dbStatusIndicator = document.getElementById('db-status-indicator');
        if (dbStatusIndicator) {
            dbStatusIndicator.textContent = 'DB Error';
            dbStatusIndicator.classList.remove('online');
            dbStatusIndicator.classList.add('offline');
        }
        appState.dbConnected = false;
        return false;
    }
}

// Data Loading Functions
async function loadEntityData() {
    try {
        const entities = await fetchData('entities');
        appState.entities = entities;
        
        // Update entity selector
        updateEntitySelector();
        
        // Update entity table in settings
        updateEntitiesTable();
        
        return entities;
    } catch (error) {
        console.error('Error loading entity data:', error);
        return [];
    }
}

async function loadAccountData() {
    try {
        const accounts = await fetchData('accounts');
        appState.accounts = accounts;
        
        // Update chart of accounts table
        updateChartOfAccountsTable();
        
        return accounts;
    } catch (error) {
        console.error('Error loading account data:', error);
        return [];
    }
}

async function loadFundData() {
    try {
        const funds = await fetchData('funds');
        appState.funds = funds;
        
        // Update funds table
        updateFundsTable();
        
        // Update dashboard fund balances
        updateDashboardFundBalances();
        
        return funds;
    } catch (error) {
        console.error('Error loading fund data:', error);
        return [];
    }
}

async function loadJournalEntryData() {
    try {
        const journalEntries = await fetchData('journal-entries');
        appState.journalEntries = journalEntries;
        
        // Update journal entries table
        updateJournalEntriesTable();
        
        // Update dashboard recent transactions
        updateDashboardRecentTransactions();
        
        // Update dashboard unposted entries
        updateDashboardUnpostedEntries();
        
        return journalEntries;
    } catch (error) {
        console.error('Error loading journal entry data:', error);
        return [];
    }
}

async function loadUserData() {
    try {
        const users = await fetchData('users');
        appState.users = users;
        
        // Update users table
        updateUsersTable();
        
        return users;
    } catch (error) {
        console.error('Error loading user data:', error);
        return [];
    }
}

async function loadDashboardData() {
    try {
        // Update dashboard title based on selected entity
        updateDashboardTitle();
        
        // Update dashboard summary cards
        updateDashboardSummaryCards();
        
        // Update fund balances table
        updateDashboardFundBalances();
        
        // Update recent transactions table
        updateDashboardRecentTransactions();
        
        // Update unposted entries table
        updateDashboardUnpostedEntries();
        
        // Initialize charts if they exist
        initializeDashboardCharts();
    } catch (error) {
        console.error('Error loading dashboard data:', error);
    }
}

// UI Update Functions
function updateEntitySelector() {
    const entitySelector = document.getElementById('entity-selector');
    if (!entitySelector || !appState.entities.length) return;
    
    // Clear existing options
    entitySelector.innerHTML = '';
    
    // Find TPF_PARENT entity (root)
    const rootEntity = appState.entities.find(entity => 
        entity.parent_entity_id === null && 
        (entity.name === 'The Principle Foundation' || entity.code === 'TPF_PARENT')
    );
    
    // Add root entity option
    if (rootEntity) {
        const option = document.createElement('option');
        option.value = rootEntity.id;
        option.textContent = `${rootEntity.name} (Consolidated)`;
        entitySelector.appendChild(option);
    }
    
    // Add child entities
    const childEntities = rootEntity 
        ? appState.entities.filter(entity => entity.parent_entity_id === rootEntity.id)
        : appState.entities.filter(entity => entity.parent_entity_id === null);
    
    childEntities.forEach(entity => {
        const option = document.createElement('option');
        option.value = entity.id;
        option.textContent = entity.name;
        entitySelector.appendChild(option);
    });
    
    // Set default selected entity
    if (!appState.selectedEntityId && rootEntity) {
        appState.selectedEntityId = rootEntity.id;
        entitySelector.value = rootEntity.id;
    } else if (appState.selectedEntityId) {
        entitySelector.value = appState.selectedEntityId;
    }
    
    // Set consolidated view toggle state based on selected entity
    const consolidatedViewToggle = document.getElementById('consolidated-view-toggle');
    if (consolidatedViewToggle && rootEntity && appState.selectedEntityId === rootEntity.id) {
        consolidatedViewToggle.checked = true;
        appState.isConsolidatedView = true;
    }
}

function updateDashboardTitle() {
    const dashboardTitle = document.getElementById('dashboard-title');
    const dashboardCurrentEntity = document.getElementById('dashboard-current-entity');
    
    if (!dashboardTitle || !appState.selectedEntityId) return;
    
    const selectedEntity = appState.entities.find(entity => entity.id === appState.selectedEntityId);
    if (selectedEntity) {
        dashboardTitle.textContent = 'Dashboard';
        
        if (dashboardCurrentEntity) {
            dashboardCurrentEntity.textContent = selectedEntity.name;
            if (appState.isConsolidatedView && selectedEntity.is_consolidated) {
                dashboardCurrentEntity.textContent += ' (Consolidated)';
            }
        }
    }
}

function updateDashboardSummaryCards() {
    const summaryCardsContainer = document.getElementById('dashboard-summary-cards');
    if (!summaryCardsContainer || !appState.selectedEntityId) return;
    
    // Get relevant funds based on selected entity and consolidated view
    const relevantFunds = getRelevantFunds();
    
    // Calculate summary values
    const totalAssets = relevantFunds.reduce((sum, fund) => sum + parseFloat(fund.balance || 0), 0);
    const totalLiabilities = 0; // This would need to be calculated from accounts if available
    const netAssets = totalAssets - totalLiabilities;
    
    // Calculate YTD revenue from journal entries
    const currentYear = new Date().getFullYear();
    const relevantEntityIds = getRelevantEntityIds();
    
    const ytdRevenue = appState.journalEntries
        .filter(entry => 
            new Date(entry.entry_date).getFullYear() === currentYear &&
            relevantEntityIds.includes(entry.entity_id) &&
            entry.type === 'Revenue'
        )
        .reduce((sum, entry) => sum + parseFloat(entry.total_amount || 0), 0);
    
    // Update the cards
    summaryCardsContainer.innerHTML = `
        <div class="card">
            <div class="card-title">Total Assets</div>
            <div class="card-value">${formatCurrency(totalAssets)}</div>
        </div>
        <div class="card">
            <div class="card-title">Total Liabilities</div>
            <div class="card-value">${formatCurrency(totalLiabilities)}</div>
        </div>
        <div class="card">
            <div class="card-title">Net Assets</div>
            <div class="card-value">${formatCurrency(netAssets)}</div>
        </div>
        <div class="card">
            <div class="card-title">YTD Revenue</div>
            <div class="card-value">${formatCurrency(ytdRevenue)}</div>
        </div>
    `;
}

function updateDashboardFundBalances() {
    const fundBalancesTable = document.getElementById('dashboard-fund-balances-table');
    if (!fundBalancesTable || !appState.selectedEntityId) return;
    
    const fundBalancesTbody = fundBalancesTable.querySelector('tbody');
    if (!fundBalancesTbody) return;
    
    // Get relevant funds based on selected entity and consolidated view
    const relevantFunds = getRelevantFunds();
    
    // Sort funds by balance (descending)
    relevantFunds.sort((a, b) => parseFloat(b.balance || 0) - parseFloat(a.balance || 0));
    
    // Calculate total for percentage
    const totalBalance = relevantFunds.reduce((sum, fund) => sum + parseFloat(fund.balance || 0), 0);
    
    // Update the fund balances table
    fundBalancesTbody.innerHTML = '';
    
    if (relevantFunds.length === 0) {
        fundBalancesTbody.innerHTML = `
            <tr>
                <td colspan="4" class="text-center">No funds found for the selected entity</td>
            </tr>
        `;
        return;
    }
    
    relevantFunds.forEach(fund => {
        const entityName = appState.entities.find(entity => entity.id === fund.entity_id)?.name || 'Unknown';
        const fundBalance = parseFloat(fund.balance || 0);
        const percentage = formatPercentage(fundBalance, totalBalance);
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${fund.name}${appState.isConsolidatedView ? ` (${entityName})` : ''}</td>
            <td>${fund.type || 'N/A'}</td>
            <td>${formatCurrency(fundBalance)}</td>
            <td>${percentage}</td>
        `;
        fundBalancesTbody.appendChild(row);
    });
}

function updateDashboardRecentTransactions() {
    const recentTransactionsTable = document.getElementById('dashboard-recent-transactions-table');
    if (!recentTransactionsTable || !appState.selectedEntityId) return;
    
    const recentTransactionsTbody = recentTransactionsTable.querySelector('tbody');
    if (!recentTransactionsTbody) return;
/**
 * Render the list of documentation files returned from the API.
 * @param {Array<Object>} documents – array of document metadata objects
 */
function renderDocuments(documents) {
    const documentGrid = document.getElementById('document-grid');
    if (!documentGrid) return;

    // Empty / error handling
    if (!documents || documents.length === 0) {
        documentGrid.innerHTML = '<div class="no-documents">No documentation found.</div>';
        return;
    }

    /* ------------------------------------------------------------
     * Stats header (file count and total size)
     * ---------------------------------------------------------- */
    const totalDocuments = documents.length;
    const totalSizeKB    = documents.reduce(
        (sum, doc) => sum + Math.round(doc.size / 1024),
        0
    );

    const statsHTML = `
        <div class="document-stats">
            <div class="stat-item">
                <span class="stat-value">${totalDocuments}</span>
                <span class="stat-label">Documents</span>
            </div>
            <div class="stat-item">
                <span class="stat-value">${totalSizeKB} KB</span>
                <span class="stat-label">Total Size</span>
            </div>
        </div>
    `;

    /* ------------------------------------------------------------
     * Document cards
     * ---------------------------------------------------------- */
    const documentsHTML = documents
        .map(doc => {
            const sizeKB       = Math.round(doc.size / 1024);
            const lastModified = new Date(doc.lastModified).toLocaleDateString();
            const description  = getDocumentDescription(doc.filename);

            return `
                <div class="document-card" onclick="openDocument('${doc.url}')">
                    <div class="document-card-header">
                        <div class="document-icon">PDF</div>
                        <h3 class="document-title">${doc.displayName}</h3>
                    </div>
                    <div class="document-info">
                        <div class="document-size">Size: ${sizeKB} KB</div>
                        <div class="document-date">Updated: ${lastModified}</div>
                    </div>
                    <div class="document-description">
                        ${description}
                    </div>
                    <div class="document-actions">
                        <button class="document-btn document-btn-primary"
                                onclick="event.stopPropagation(); openDocument('${doc.url}')">
                            View PDF
                        </button>
                        <button class="document-btn document-btn-secondary"
                                onclick="event.stopPropagation(); downloadDocument('${doc.url}', '${doc.filename}')">
                            Download
                        </button>
                    </div>
                </div>
            `;
        })
        .join('');

    /* ------------------------------------------------------------
     * Inject into DOM
     * ---------------------------------------------------------- */
    documentGrid.innerHTML =
        statsHTML + '<div class="document-grid">' + documentsHTML + '</div>';
}

// -----------------------------------------------------------------
// Documentation helper utilities
// -----------------------------------------------------------------

/**
 * Return a human-readable description for a given documentation file.
 * Extend this map as new docs are added.
 */
function getDocumentDescription(filename) {
    const descriptions = {
        'AccuFund_Migration_Guide_v8.6.pdf':
            'Complete guide for migrating from AccuFund to the Nonprofit Fund Accounting System, including data import procedures and validation steps.',
        'AccuFund_Migration_Steps_v8.6.pdf':
            'Step-by-step instructions for the AccuFund migration process, with detailed procedures and troubleshooting tips.',
        'AccuFund_Verification_Procedure_v8.6.pdf':
            'Verification and validation procedures to ensure data integrity after AccuFund migration.',
        'Administrator_Guide_v8.6.pdf':
            'Comprehensive administrator guide covering system setup, user management, entity configuration, and maintenance procedures.',
        'User_Guide_v8.6.pdf':
            'End-user guide covering daily operations, journal entries, reporting, and system features.',
        'Windows_HyperV_Deployment_Guide_v8.6.pdf':
            'Step-by-step guide for deploying the system on Windows Hyper-V with Ubuntu 22.04 LTS virtual machines.',
        'Zoho_Books_Comparison_v8.6.pdf':
            'Detailed comparison between the Nonprofit Fund Accounting System and Zoho Books, highlighting key differences and migration considerations.'
    };
    return descriptions[filename] || 'Documentation file for the Nonprofit Fund Accounting System.';
}

/**
 * Open a document in a new browser tab.
 */
function openDocument(url) {
    window.open(url, '_blank', 'noopener');
}

/**
 * Force-download a document instead of opening it.
 */
function downloadDocument(url, filename) {
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

            </tr>
        `;
        return;
    }
    
    relevantEntries.forEach(entry => {
        const entityName = appState.entities.find(entity => entity.id === entry.entity_id)?.name || 'Unknown';
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${formatDate(entry.entry_date)}</td>
            <td>${entry.reference_number || 'N/A'}</td>
            <td>${entry.description || 'N/A'}${appState.isConsolidatedView ? ` (${entityName})` : ''}</td>
            <td>${formatCurrency(entry.total_amount)}</td>
            <td><span class="status status-${entry.status.toLowerCase()}">${entry.status}</span></td>
        `;
        recentTransactionsTbody.appendChild(row);
    });
}

function updateDashboardUnpostedEntries() {
    const unpostedEntriesTable = document.getElementById('dashboard-unposted-entries-table');
    if (!unpostedEntriesTable || !appState.selectedEntityId) return;
    
    const unpostedEntriesTbody = unpostedEntriesTable.querySelector('tbody');
    if (!unpostedEntriesTbody) return;
    
    // Get relevant journal entries based on selected entity and consolidated view
    const relevantEntityIds = getRelevantEntityIds();
    
    let unpostedEntries = appState.journalEntries.filter(entry => 
        relevantEntityIds.includes(entry.entity_id) && 
        entry.status === 'Draft'
    );
    
    // Sort by date (most recent first)
    unpostedEntries.sort((a, b) => new Date(b.entry_date) - new Date(a.entry_date));
    
    // Update the unposted entries table
    unpostedEntriesTbody.innerHTML = '';
    
    if (unpostedEntries.length === 0) {
        unpostedEntriesTbody.innerHTML = `
            <tr>
                <td colspan="6" class="text-center">No unposted entries found</td>
            </tr>
        `;
        return;
    }
    
    unpostedEntries.forEach(entry => {
        const entityName = appState.entities.find(entity => entity.id === entry.entity_id)?.name || 'Unknown';
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${formatDate(entry.entry_date)}</td>
            <td>${entry.reference_number || 'N/A'}</td>
            <td>${entry.description || 'N/A'}${appState.isConsolidatedView ? ` (${entityName})` : ''}</td>
            <td>${formatCurrency(entry.total_amount)}</td>
            <td>${entry.created_by || 'System'}</td>
            <td>
                <button class="action-button btn-post-entry" data-id="${entry.id}">Post</button>
                <button class="action-button btn-edit-entry" data-id="${entry.id}">Edit</button>
            </td>
        `;
        unpostedEntriesTbody.appendChild(row);
    });
    
    // Add event listeners for post and edit buttons
    unpostedEntriesTbody.querySelectorAll('.btn-post-entry').forEach(button => {
        button.addEventListener('click', () => postJournalEntry(button.dataset.id));
    });
    
    unpostedEntriesTbody.querySelectorAll('.btn-edit-entry').forEach(button => {
        button.addEventListener('click', () => openJournalEntryModal(button.dataset.id));
    });
}

function updateChartOfAccountsTable() {
    const chartOfAccountsTable = document.getElementById('chart-of-accounts-table');
    if (!chartOfAccountsTable) return;
    
    const chartOfAccountsTbody = chartOfAccountsTable.querySelector('tbody');
    if (!chartOfAccountsTbody) return;
    
    // Sort accounts by code
    const sortedAccounts = [...appState.accounts].sort((a, b) => a.code.localeCompare(b.code));
    
    // Update the chart of accounts table
    chartOfAccountsTbody.innerHTML = '';
    
    if (sortedAccounts.length === 0) {
        chartOfAccountsTbody.innerHTML = `
            <tr>
                <td colspan="6" class="text-center">No accounts found</td>
            </tr>
        `;
        return;
    }
    
    sortedAccounts.forEach(account => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${account.code}</td>
            <td>${account.name}</td>
            <td>${account.type}</td>
            <td>${formatCurrency(account.balance)}</td>
            <td><span class="status status-${account.status.toLowerCase()}">${account.status}</span></td>
            <td>
                <button class="action-button btn-edit-account" data-id="${account.id}">Edit</button>
            </td>
        `;
        chartOfAccountsTbody.appendChild(row);
    });
    
    // Add event listeners for edit buttons
    chartOfAccountsTbody.querySelectorAll('.btn-edit-account').forEach(button => {
        button.addEventListener('click', () => openAccountModal(button.dataset.id));
    });
}

function updateFundsTable() {
    const fundsTable = document.getElementById('funds-table');
    if (!fundsTable) return;
    
    const fundsTbody = fundsTable.querySelector('tbody');
    if (!fundsTbody) return;
    
    // Determine filtering mode (current entity vs all entities)
    const fundsFilterSelect = document.getElementById('funds-filter-select');
    const filterMode = fundsFilterSelect ? fundsFilterSelect.value : 'current';

    // Build list of funds respecting the chosen filter
    let displayFunds = appState.funds;
    if (filterMode !== 'all') {
        // Existing behaviour – filter by selected entity / consolidated view
        if (appState.selectedEntityId) {
            if (!appState.isConsolidatedView) {
                displayFunds = appState.funds.filter(fund => fund.entity_id === appState.selectedEntityId);
            } else {
                const relevantEntityIds = getRelevantEntityIds();
                displayFunds = appState.funds.filter(fund => relevantEntityIds.includes(fund.entity_id));
            }
        }
    }
    
    // Sort funds by code
    displayFunds.sort((a, b) => a.code.localeCompare(b.code));
    
    // Update the funds table
    fundsTbody.innerHTML = '';
    
    if (displayFunds.length === 0) {
        fundsTbody.innerHTML = `
            <tr>
                <td colspan="7" class="text-center">No funds found</td>
            </tr>
        `;
        return;
    }
    
    displayFunds.forEach(fund => {
        const entityName = appState.entities.find(entity => entity.id === fund.entity_id)?.name || 'Unknown';
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${fund.code}</td>
            <td>${fund.name}</td>
            <td>${fund.type || 'N/A'}</td>
            <td>${entityName}</td>
            <td>${formatCurrency(fund.balance)}</td>
            <td><span class="status status-${fund.status.toLowerCase()}">${fund.status}</span></td>
            <td>
                <button class="action-button btn-edit-fund" data-id="${fund.id}">Edit</button>
            </td>
        `;
        fundsTbody.appendChild(row);
    });
    
    // Add event listeners for edit buttons
    fundsTbody.querySelectorAll('.btn-edit-fund').forEach(button => {
        button.addEventListener('click', () => openFundModal(button.dataset.id));
    });
}

function updateJournalEntriesTable() {
    const journalEntriesTable = document.getElementById('journal-entries-table');
    if (!journalEntriesTable) return;
    
    const journalEntriesTbody = journalEntriesTable.querySelector('tbody');
    if (!journalEntriesTbody) return;
    
    /* ------------------------------------------------------------------
     * Determine filter mode – current entity vs all entities
     * ------------------------------------------------------------------ */
    const jeFilterSelect = document.getElementById('journal-entries-filter-select');
    const jeFilterMode   = jeFilterSelect ? jeFilterSelect.value : 'current';

    // Build list of entries respecting the chosen filter
    let displayEntries = appState.journalEntries;
    
    if (jeFilterMode !== 'all') {
        // Existing behaviour – filter by selected entity / consolidated view
        if (appState.selectedEntityId) {
            if (!appState.isConsolidatedView) {
                // Show only entries for the selected entity
                displayEntries = displayEntries.filter(entry => entry.entity_id === appState.selectedEntityId);
            } else {
                // Show entries for the selected entity and its children
                const relevantEntityIds = getRelevantEntityIds();
                displayEntries = displayEntries.filter(entry => relevantEntityIds.includes(entry.entity_id));
            }
        }
    }
    
    // Sort entries by date (most recent first)
    displayEntries.sort((a, b) => new Date(b.entry_date) - new Date(a.entry_date));
    
    // Update the journal entries table
    journalEntriesTbody.innerHTML = '';
    
    if (displayEntries.length === 0) {
        journalEntriesTbody.innerHTML = `
            <tr>
                <td colspan="9" class="text-center">No journal entries found</td>
            </tr>
        `;
        return;
    }
    
    displayEntries.forEach(entry => {
        const entityName = appState.entities.find(entity => entity.id === entry.entity_id)?.name || 'Unknown';
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${formatDate(entry.entry_date)}</td>
            <td>${entry.reference_number || 'N/A'}</td>
            <td>${entry.description || 'N/A'}${appState.isConsolidatedView ? ` (${entityName})` : ''}</td>
            <td>N/A</td>
            <td>${entityName}</td>
            <td>${formatCurrency(entry.total_amount)}</td>
            <td><span class="status status-${entry.status.toLowerCase()}">${entry.status}</span></td>
            <td>${entry.created_by || 'System'}</td>
            <td>
                <button class="action-button btn-view-entry" data-id="${entry.id}">View</button>
                ${entry.status === 'Draft' ? `<button class="action-button btn-edit-entry" data-id="${entry.id}">Edit</button>` : ''}
                <button class="action-button btn-delete-entry" data-id="${entry.id}">Delete</button>
            </td>
        `;
        journalEntriesTbody.appendChild(row);
    });
    
    // Add event listeners for view and edit buttons
    journalEntriesTbody.querySelectorAll('.btn-view-entry').forEach(button => {
        button.addEventListener('click', () => openJournalEntryModal(button.dataset.id, true));
    });
    
    journalEntriesTbody.querySelectorAll('.btn-edit-entry').forEach(button => {
        button.addEventListener('click', () => openJournalEntryModal(button.dataset.id));
    });

    // delete buttons
    journalEntriesTbody.querySelectorAll('.btn-delete-entry').forEach(button => {
        button.addEventListener('click', () => deleteJournalEntry(button.dataset.id));
    });
}

function updateEntitiesTable() {
    const entitiesTable = document.getElementById('entities-table');
    if (!entitiesTable) return;
    
    const entitiesTbody = entitiesTable.querySelector('tbody');
    if (!entitiesTbody) return;
    
    // Sort entities by name
    const sortedEntities = [...appState.entities].sort((a, b) => a.name.localeCompare(b.name));
    
    // Update the entities table
    entitiesTbody.innerHTML = '';
    
    if (sortedEntities.length === 0) {
        entitiesTbody.innerHTML = `
            <tr>
                <td colspan="8" class="text-center">No entities found</td>
            </tr>
        `;
        return;
    }
    
    sortedEntities.forEach(entity => {
        const parentEntity = appState.entities.find(e => e.id === entity.parent_entity_id);
        const parentName = parentEntity ? parentEntity.name : 'None (Top Level)';
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${entity.code}</td>
            <td>${entity.name}</td>
            <td>${parentName}</td>
            <td><span class="status status-${entity.status.toLowerCase()}">${entity.status}</span></td>
            <td>${entity.base_currency || 'USD'}</td>
            <td>${entity.fiscal_year_start || '01-01'}</td>
            <td>${entity.is_consolidated ? 'Yes' : 'No'}</td>
            <td>
                <button class="action-button btn-edit-entity" data-id="${entity.id}">Edit</button>
                <button class="action-button btn-delete-entity" data-id="${entity.id}">Delete</button>
            </td>
        `;
        entitiesTbody.appendChild(row);
    });
    
    // Add event listeners for edit and delete buttons
    entitiesTbody.querySelectorAll('.btn-edit-entity').forEach(button => {
        button.addEventListener('click', () => openEntityModal(button.dataset.id));
    });
    
    entitiesTbody.querySelectorAll('.btn-delete-entity').forEach(button => {
        button.addEventListener('click', () => deleteEntity(button.dataset.id));
    });
    
    // Update entity hierarchy visualization
    updateEntityHierarchyVisualization();
}

function updateEntityHierarchyVisualization() {
    const entityRelationshipViz = document.getElementById('entity-relationship-viz');
    if (!entityRelationshipViz) return;
    
    // Clear existing content
    entityRelationshipViz.innerHTML = '';
    
    // Build hierarchy data
    const hierarchyData = buildEntityHierarchyData();
    
    if (!hierarchyData.root) {
        entityRelationshipViz.innerHTML = '<p class="text-center">No entity hierarchy found</p>';
        return;
    }
    
    // Create visualization container
    const vizContainer = document.createElement('div');
    vizContainer.className = 'hierarchy-visualization';
    
    // Create root node
    const rootNode = createEntityHierarchyNode(hierarchyData.root);
    vizContainer.appendChild(rootNode);
    
    // Add to container
    entityRelationshipViz.appendChild(vizContainer);
}

function buildEntityHierarchyData() {
    // Create entity map for quick lookup
    const entityMap = {};
    appState.entities.forEach(entity => {
        entityMap[entity.id] = {
            ...entity,
            type: appState.entityTypes.ENTITY,
            children: []
        };
    });
    
    // Find root entity (TPF_PARENT)
    const rootEntity = appState.entities.find(entity => 
        entity.parent_entity_id === null && 
        (entity.name === 'The Principle Foundation' || entity.code === 'TPF_PARENT')
    );
    
    // If no specific root, use any entity without a parent
    const fallbackRoot = rootEntity || appState.entities.find(entity => entity.parent_entity_id === null);
    
    // Build the hierarchy
    const hierarchy = {
        root: fallbackRoot ? entityMap[fallbackRoot.id] : null,
        entities: entityMap
    };
    
    // Add child entities to their parents
    appState.entities.forEach(entity => {
        if (entity.parent_entity_id && entityMap[entity.parent_entity_id]) {
            entityMap[entity.parent_entity_id].children.push(entityMap[entity.id]);
        }
    });
    
    // Add funds to their respective entities
    appState.funds.forEach(fund => {
        const fundObj = {
            ...fund,
            type: appState.entityTypes.FUND,
            children: []
        };
        
        if (entityMap[fund.entity_id]) {
            entityMap[fund.entity_id].children.push(fundObj);
        }
    });
    
    return hierarchy;
}

function createEntityHierarchyNode(node) {
    if (!node) return null;
    
    const nodeContainer = document.createElement('div');
    nodeContainer.className = `hierarchy-node ${node.type === appState.entityTypes.FUND ? 'fund-node' : 'entity-node'}`;
    nodeContainer.dataset.id = node.id;
    nodeContainer.dataset.type = node.type;
    
    // Create node header
    const nodeHeader = document.createElement('div');
    nodeHeader.className = 'node-header';
    
    // Create node title
    const nodeTitle = document.createElement('div');
    nodeTitle.className = 'node-title';
    nodeTitle.textContent = `${node.name} (${node.code})`;
    
    // Create consolidated indicator if applicable
    if (node.type !== appState.entityTypes.FUND && node.is_consolidated) {
        const consolidatedIndicator = document.createElement('span');
        consolidatedIndicator.className = 'consolidated-indicator';
        consolidatedIndicator.title = 'This entity consolidates its children';
        consolidatedIndicator.textContent = ' [Consolidated]';
        nodeTitle.appendChild(consolidatedIndicator);
    }
    
    // Create node actions
    const nodeActions = document.createElement('div');
    nodeActions.className = 'node-actions';
    
    // Add edit button for entities
    if (node.type === appState.entityTypes.ENTITY) {
        const editButton = document.createElement('button');
        editButton.className = 'btn-icon edit-entity';
        editButton.innerHTML = '✏️';
        editButton.title = 'Edit Entity';
        editButton.addEventListener('click', () => openEntityModal(node.id));
        nodeActions.appendChild(editButton);
    }
    
    // Add children if any
    if (node.children && node.children.length > 0) {
        // Create toggle button for expanding/collapsing
        const toggleButton = document.createElement('button');
        toggleButton.className = 'toggle-children';
        toggleButton.textContent = '▼';
        
        // Create children container
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'node-children';
        
        toggleButton.addEventListener('click', () => {
            childrenContainer.classList.toggle('collapsed');
            toggleButton.textContent = childrenContainer.classList.contains('collapsed') ? '►' : '▼';
        });
        
        // Sort children: entities first, then funds
        const entityChildren = node.children.filter(child => child.type === appState.entityTypes.ENTITY);
        const fundChildren = node.children.filter(child => child.type === appState.entityTypes.FUND);
        
        // Add entity children
        entityChildren.forEach(child => {
            const childNode = createEntityHierarchyNode(child);
            if (childNode) {
                childrenContainer.appendChild(childNode);
            }
        });
        
        // Add fund children
        fundChildren.forEach(child => {
            const childNode = createEntityHierarchyNode(child);
            if (childNode) {
                childrenContainer.appendChild(childNode);
            }
        });
        
        // Only add toggle and children container if there are actually children
        if (childrenContainer.children.length > 0) {
            nodeHeader.insertBefore(toggleButton, nodeHeader.firstChild);
            nodeContainer.appendChild(childrenContainer);
        }
    }
    
    // Assemble the node
    nodeHeader.appendChild(nodeTitle);
    nodeHeader.appendChild(nodeActions);
    nodeContainer.insertBefore(nodeHeader, nodeContainer.firstChild);
    
    return nodeContainer;
}

function updateUsersTable() {
    const usersTable = document.getElementById('users-table');
    if (!usersTable) return;
    
    const usersTbody = usersTable.querySelector('tbody');
    if (!usersTbody) return;
    
    // Sort users by name
    const sortedUsers = [...appState.users].sort((a, b) => a.name.localeCompare(b.name));
    
    // Update the users table
    usersTbody.innerHTML = '';
    
    if (sortedUsers.length === 0) {
        usersTbody.innerHTML = `
            <tr>
                <td colspan="5" class="text-center">No users found</td>
            </tr>
        `;
        return;
    }
    
    sortedUsers.forEach(user => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${user.name}</td>
            <td>${user.email}</td>
            <td>${user.role}</td>
            <td><span class="status status-${user.status.toLowerCase()}">${user.status}</span></td>
            <td>
                <button class="action-button btn-edit-user" data-id="${user.id}">Edit</button>
            </td>
        `;
        usersTbody.appendChild(row);
    });
    
    // Add event listeners for edit buttons
    usersTbody.querySelectorAll('.btn-edit-user').forEach(button => {
        button.addEventListener('click', () => openUserModal(button.dataset.id));
    });
}

// Chart Initialization
function initializeDashboardCharts() {
    initializeFundBalanceChart();
    initializeIncomeExpenseChart();
    initializeFundDistributionChart();
}

function initializeFundBalanceChart() {
    const canvas = document.getElementById('fund-balance-chart');
    if (!canvas || !window.Chart) return;
    
    // Get relevant funds
    const relevantFunds = getRelevantFunds();
    
    // Prepare data
    const fundNames = relevantFunds.slice(0, 5).map(fund => fund.name);
    const fundBalances = relevantFunds.slice(0, 5).map(fund => parseFloat(fund.balance || 0));
    
    // Create chart
    new Chart(canvas, {
        type: 'bar',
        data: {
            labels: fundNames,
            datasets: [{
                label: 'Fund Balance',
                data: fundBalances,
                backgroundColor: 'rgba(33, 150, 243, 0.7)',
                borderColor: 'rgba(33, 150, 243, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatCurrency(value)
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: context => formatCurrency(context.raw)
                    }
                }
            }
        }
    });
}

function initializeIncomeExpenseChart() {
    const canvas = document.getElementById('income-expense-chart');
    if (!canvas || !window.Chart) return;
    
    // Get relevant journal entries
    const relevantEntityIds = getRelevantEntityIds();
    const currentYear = new Date().getFullYear();
    
    // Get monthly data for the current year
    const months = Array.from({ length: 12 }, (_, i) => i + 1);
    
    const incomeData = months.map(month => {
        const startDate = new Date(currentYear, month - 1, 1);
        const endDate = new Date(currentYear, month, 0);
        
        return appState.journalEntries
            .filter(entry => 
                relevantEntityIds.includes(entry.entity_id) &&
                entry.type === 'Revenue' &&
                entry.status === 'Posted' &&
                new Date(entry.entry_date) >= startDate &&
                new Date(entry.entry_date) <= endDate
            )
            .reduce((sum, entry) => sum + parseFloat(entry.total_amount || 0), 0);
    });
    
    const expenseData = months.map(month => {
        const startDate = new Date(currentYear, month - 1, 1);
        const endDate = new Date(currentYear, month, 0);
        
        return appState.journalEntries
            .filter(entry => 
                relevantEntityIds.includes(entry.entity_id) &&
                entry.type === 'Expense' &&
                entry.status === 'Posted' &&
                new Date(entry.entry_date) >= startDate &&
                new Date(entry.entry_date) <= endDate
            )
            .reduce((sum, entry) => sum + parseFloat(entry.total_amount || 0), 0);
    });
    
    // Create chart
    new Chart(canvas, {
        type: 'line',
        data: {
            labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            datasets: [
                {
                    label: 'Income',
                    data: incomeData,
                    backgroundColor: 'rgba(76, 175, 80, 0.2)',
                    borderColor: 'rgba(76, 175, 80, 1)',
                    borderWidth: 2,
                    tension: 0.3
                },
                {
                    label: 'Expenses',
                    data: expenseData,
                    backgroundColor: 'rgba(244, 67, 54, 0.2)',
                    borderColor: 'rgba(244, 67, 54, 1)',
                    borderWidth: 2,
                    tension: 0.3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatCurrency(value)
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: context => formatCurrency(context.raw)
                    }
                }
            }
        }
    });
}

function initializeFundDistributionChart() {
    const canvas = document.getElementById('fund-distribution-chart');
    if (!canvas || !window.Chart) return;
    
    // Get relevant funds
    const relevantFunds = getRelevantFunds();
    
    // Group funds by type
    const fundTypes = {};
    relevantFunds.forEach(fund => {
        const type = fund.type || 'Other';
        if (!fundTypes[type]) {
            fundTypes[type] = 0;
        }
        fundTypes[type] += parseFloat(fund.balance || 0);
    });
    
    // Prepare data
    const types = Object.keys(fundTypes);
    const balances = Object.values(fundTypes);
    
    // Create chart
    new Chart(canvas, {
        type: 'pie',
        data: {
            labels: types,
            datasets: [{
                data: balances,
                backgroundColor: [
                    'rgba(33, 150, 243, 0.7)',
                    'rgba(76, 175, 80, 0.7)',
                    'rgba(255, 193, 7, 0.7)',
                    'rgba(156, 39, 176, 0.7)',
                    'rgba(0, 188, 212, 0.7)'
                ],
                borderColor: [
                    'rgba(33, 150, 243, 1)',
                    'rgba(76, 175, 80, 1)',
                    'rgba(255, 193, 7, 1)',
                    'rgba(156, 39, 176, 1)',
                    'rgba(0, 188, 212, 1)'
                ],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    callbacks: {
                        label: context => {
                            const value = context.raw;
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((value / total) * 100).toFixed(1);
                            return `${context.label}: ${formatCurrency(value)} (${percentage}%)`;
                        }
                    }
                }
            }
        }
    });
}

// Helper Functions
function getRelevantEntityIds() {
    if (!appState.selectedEntityId) return [];
    
    if (!appState.isConsolidatedView) {
        // Just the selected entity
        return [appState.selectedEntityId];
    } else {
        // Selected entity and its children
        const selectedEntity = appState.entities.find(entity => entity.id === appState.selectedEntityId);
        
        if (selectedEntity && selectedEntity.is_consolidated) {
            const childEntityIds = appState.entities
                .filter(entity => entity.parent_entity_id === selectedEntity.id)
                .map(entity => entity.id);
            
            return [selectedEntity.id, ...childEntityIds];
        } else {
            return [appState.selectedEntityId];
        }
    }
}

function getRelevantFunds() {
    const relevantEntityIds = getRelevantEntityIds();
    
    return appState.funds.filter(fund => 
        relevantEntityIds.includes(fund.entity_id)
    );
}

// Modal Functions
function openEntityModal(entityId = null) {
    const entityModal = document.getElementById('entity-modal');
    if (!entityModal) return;
    
    // Reset form
    document.getElementById('entity-id-edit').value = '';
    document.getElementById('entity-name-input').value = '';
    document.getElementById('entity-code-input').value = '';
    document.getElementById('entity-parent-select').value = '';
    document.getElementById('entity-consolidated-checkbox').checked = false;
    document.getElementById('entity-currency-select').value = 'USD';
    document.getElementById('entity-fiscal-start-input').value = '01-01';
    document.getElementById('entity-status-select').value = 'Active';
    document.getElementById('entity-description-textarea').value = '';
    
    // Update modal title
    document.getElementById('entity-modal-title-text').textContent = entityId ? 'Edit Entity' : 'Add Entity';
    
    // Populate parent entity dropdown
    populateParentEntityDropdown(entityId);
    
    if (entityId) {
        // Edit mode - populate form with entity data
        const entity = appState.entities.find(e => e.id === entityId);
        if (entity) {
            document.getElementById('entity-id-edit').value = entity.id;
            document.getElementById('entity-name-input').value = entity.name;
            document.getElementById('entity-code-input').value = entity.code;
            document.getElementById('entity-parent-select').value = entity.parent_entity_id || '';
            document.getElementById('entity-consolidated-checkbox').checked = entity.is_consolidated || false;
            document.getElementById('entity-currency-select').value = entity.base_currency || 'USD';
            document.getElementById('entity-fiscal-start-input').value = entity.fiscal_year_start || '01-01';
            document.getElementById('entity-status-select').value = entity.status || 'Active';
            document.getElementById('entity-description-textarea').value = entity.description || '';
        }
    }
    
    // Show modal
    entityModal.classList.remove('hidden');
    entityModal.style.display = 'block';
}

function populateParentEntityDropdown(currentEntityId = null) {
    const parentSelect = document.getElementById('entity-parent-select');
    if (!parentSelect) return;
    
    // Clear existing options
    parentSelect.innerHTML = '<option value="">-- No Parent (Top Level) --</option>';
    
    // Add all entities except the current one being edited
    appState.entities.forEach(entity => {
        if (entity.id !== currentEntityId) {
            const option = document.createElement('option');
            option.value = entity.id;
            option.textContent = entity.name;
            parentSelect.appendChild(option);
        }
    });
}

function openFundModal(fundId = null) {
    const fundModal = document.getElementById('fund-modal');
    if (!fundModal) return;
    
    // Reset form
    document.getElementById('edit-fund-id-input').value = '';
    document.getElementById('fund-code-input').value = '';
    document.getElementById('fund-name-input').value = '';
    document.getElementById('fund-type-select').value = 'Unrestricted';
    document.getElementById('fund-status-select').value = 'Active';
    document.getElementById('fund-description-textarea').value = '';
    
    // Update modal title
    document.getElementById('fund-modal-title').textContent = fundId ? 'Edit Fund' : 'Add Fund';
    
    if (fundId) {
        // Edit mode - populate form with fund data
        const fund = appState.funds.find(f => f.id === fundId);
        if (fund) {
            document.getElementById('edit-fund-id-input').value = fund.id;
            document.getElementById('fund-code-input').value = fund.code;
            document.getElementById('fund-name-input').value = fund.name;
            document.getElementById('fund-type-select').value = fund.type || 'Unrestricted';
            document.getElementById('fund-status-select').value = fund.status || 'Active';
            document.getElementById('fund-description-textarea').value = fund.description || '';
        }
        // Show delete button in edit mode
        const delBtn = document.getElementById('delete-fund-btn');
        if (delBtn) delBtn.style.display = 'inline-block';
    }
    else {
        // Hide delete button in create mode
        const delBtn = document.getElementById('delete-fund-btn');
        if (delBtn) delBtn.style.display = 'none';
    }
    
    // Show modal
    fundModal.classList.remove('hidden');
    fundModal.style.display = 'block';
}

// Delete Fund
async function deleteFund(fundId) {
    if (!fundId) return;
    if (!confirm('Are you sure you want to delete this fund? This action cannot be undone.')) return;
    try {
        const response = await fetch(`/api/funds/${fundId}`, { method: 'DELETE' });

        /* --- Enhanced error handling ------------------------------------- */
        if (!response.ok) {
            // Try to parse error details from server (JSON preferred, fallback to text)
            let serverMsg = `API Error: ${response.status}`;
            try {
                const data = await response.json();
                if (data && data.message) serverMsg = data.message;
            } catch {
                try {
                    const text = await response.text();
                    if (text) serverMsg = text;
                } catch { /* ignore */ }
            }
            throw new Error(serverMsg);
        }
        /* ----------------------------------------------------------------- */

        // Close modal
        const fundModal = document.getElementById('fund-modal');
        if (fundModal) {
            fundModal.classList.add('hidden');
            fundModal.style.display = 'none';
        }
        // Reload funds
        await loadFundData();
        alert('Fund deleted successfully.');
    } catch (err) {
        console.error('Error deleting fund:', err);
        alert('Error deleting fund: ' + err.message);
    }
}

function openAccountModal(accountId = null) {
    const accountModal = document.getElementById('account-modal');
    if (!accountModal) return;
    
    // Reset form
    document.getElementById('edit-account-id-input').value = '';
    document.getElementById('account-code-input').value = '';
    document.getElementById('account-name-input').value = '';
    document.getElementById('account-type-select').value = 'Asset';
    document.getElementById('account-status-select').value = 'Active';
    document.getElementById('account-description-textarea').value = '';
    
    // Update modal title
    document.getElementById('account-modal-title').textContent = accountId ? 'Edit Account' : 'Add Account';
    
    if (accountId) {
        // Edit mode - populate form with account data
        const account = appState.accounts.find(a => a.id === accountId);
        if (account) {
            document.getElementById('edit-account-id-input').value = account.id;
            document.getElementById('account-code-input').value = account.code;
            document.getElementById('account-name-input').value = account.name;
            document.getElementById('account-type-select').value = account.type || 'Asset';
            document.getElementById('account-status-select').value = account.status || 'Active';
            document.getElementById('account-description-textarea').value = account.description || '';
        }
    }
    
    // Show modal
    accountModal.classList.remove('hidden');
    accountModal.style.display = 'block';
}

function openJournalEntryModal(entryId = null, readOnly = false) {
    const journalEntryModal = document.getElementById('journal-entry-modal');
    if (!journalEntryModal) return;
    
    // Reset form
    document.getElementById('edit-je-id-input').value = '';
    document.getElementById('journal-entry-date').value = new Date().toISOString().split('T')[0];
    document.getElementById('journal-entry-reference').value = 'JE-' + new Date().getFullYear() + '-' + Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    document.getElementById('journal-entry-description').value = '';
    document.getElementById('journal-entry-is-inter-entity').checked = false;
    
    // Update modal title
    document.getElementById('journal-entry-modal-title').textContent = entryId ? (readOnly ? 'View Journal Entry' : 'Edit Journal Entry') : 'New Journal Entry';
    
    if (entryId) {
        // Edit/View mode - populate form with journal entry data
        const entry = appState.journalEntries.find(je => je.id === entryId);
        if (entry) {
            document.getElementById('edit-je-id-input').value = entry.id;
            document.getElementById('journal-entry-date').value = entry.entry_date ? new Date(entry.entry_date).toISOString().split('T')[0] : '';
            document.getElementById('journal-entry-reference').value = entry.reference_number || '';
            document.getElementById('journal-entry-description').value = entry.description || '';
            document.getElementById('journal-entry-is-inter-entity').checked = entry.is_inter_entity || false;
        }
    }
    
    // Set read-only state if viewing
    if (readOnly) {
        document.getElementById('journal-entry-date').disabled = true;
        document.getElementById('journal-entry-description').disabled = true;
        document.getElementById('journal-entry-is-inter-entity').disabled = true;
        document.getElementById('btn-save-journal-draft').style.display = 'none';
        document.getElementById('btn-save-journal-post').style.display = 'none';
    } else {
        document.getElementById('journal-entry-date').disabled = false;
        document.getElementById('journal-entry-description').disabled = false;
        document.getElementById('journal-entry-is-inter-entity').disabled = false;
        document.getElementById('btn-save-journal-draft').style.display = 'inline-block';
        document.getElementById('btn-save-journal-post').style.display = 'inline-block';
    }
    
    // Show modal
    journalEntryModal.classList.remove('hidden');
    journalEntryModal.style.display = 'block';
}

function openUserModal(userId = null) {
    const userModal = document.getElementById('user-modal');
    if (!userModal) return;
    
    // Reset form
    document.getElementById('edit-user-id-input').value = '';
    document.getElementById('user-name-input').value = '';
    
    // Update modal title
    document.getElementById('user-modal-title').textContent = userId ? 'Edit User' : 'Add User';
    
    if (userId) {
        // Edit mode - populate form with user data
        const user = appState.users.find(u => u.id === userId);
        if (user) {
            document.getElementById('edit-user-id-input').value = user.id;
            document.getElementById('user-name-input').value = user.name;
        }
    }
    
    // Show modal
    userModal.classList.remove('hidden');
    userModal.style.display = 'block';
}

// Entity CRUD Operations
async function saveEntity() {
    const entityId = document.getElementById('entity-id-edit').value;
    const entityData = {
        name: document.getElementById('entity-name-input').value,
        code: document.getElementById('entity-code-input').value,
        parent_entity_id: document.getElementById('entity-parent-select').value || null,
        is_consolidated: document.getElementById('entity-consolidated-checkbox').checked,
        base_currency: document.getElementById('entity-currency-select').value,
        fiscal_year_start: document.getElementById('entity-fiscal-start-input').value,
        status: document.getElementById('entity-status-select').value,
        description: document.getElementById('entity-description-textarea').value
    };
    
    try {
        let savedEntity;
        
        if (entityId) {
            // Update existing entity
            savedEntity = await saveData(`entities/${entityId}`, entityData, 'PUT');
        } else {
            // Create new entity
            savedEntity = await saveData('entities', entityData);
        }
        
        // Close modal
        const entityModal = document.getElementById('entity-modal');
        if (entityModal) {
            entityModal.classList.add('hidden');
            entityModal.style.display = 'none';
        }
        
        // Reload entity data
        await loadEntityData();
        
        return savedEntity;
    } catch (error) {
        console.error('Error saving entity:', error);
        alert('Error saving entity: ' + error.message);
        return null;
    }
}

async function deleteEntity(entityId) {
    if (!confirm('Are you sure you want to delete this entity? This action cannot be undone.')) {
        return;
    }
    
    try {
        // Check if entity has children
        const hasChildren = appState.entities.some(entity => entity.parent_entity_id === entityId);
        if (hasChildren) {
            alert('Cannot delete entity with child entities. Please delete or reassign child entities first.');
            return;
        }
        
        // Check if entity has funds
        const hasFunds = appState.funds.some(fund => fund.entity_id === entityId);
        if (hasFunds) {
            alert('Cannot delete entity with funds. Please delete or reassign funds first.');
            return;
        }
        
        // Delete entity
        await fetch(`/api/entities/${entityId}`, { method: 'DELETE' });
        
        // Reload entity data
        await loadEntityData();
        
        alert('Entity deleted successfully.');
    } catch (error) {
        console.error('Error deleting entity:', error);
        alert('Error deleting entity: ' + error.message);
    }
}

// Fund CRUD Operations
async function saveFund() {
    const fundId = document.getElementById('edit-fund-id-input').value;
    const fundData = {
        code: document.getElementById('fund-code-input').value,
        name: document.getElementById('fund-name-input').value,
        type: document.getElementById('fund-type-select').value,
        status: document.getElementById('fund-status-select').value,
        description: document.getElementById('fund-description-textarea').value,
        entity_id: appState.selectedEntityId
    };
    
    try {
        let savedFund;
        
        if (fundId) {
            // Update existing fund
            savedFund = await saveData(`funds/${fundId}`, fundData, 'PUT');
        } else {
            // Create new fund
            savedFund = await saveData('funds', fundData);
        }
        
        // Close modal
        const fundModal = document.getElementById('fund-modal');
        if (fundModal) {
            fundModal.classList.add('hidden');
            fundModal.style.display = 'none';
        }
        
        // Reload fund data
        await loadFundData();
        
        return savedFund;
    } catch (error) {
        console.error('Error saving fund:', error);
        alert('Error saving fund: ' + error.message);
        return null;
    }
}

// Account CRUD Operations
async function saveAccount() {
    const accountId = document.getElementById('edit-account-id-input').value;
    const accountData = {
        code: document.getElementById('account-code-input').value,
        name: document.getElementById('account-name-input').value,
        type: document.getElementById('account-type-select').value,
        status: document.getElementById('account-status-select').value,
        description: document.getElementById('account-description-textarea').value
    };
    
    try {
        let savedAccount;
        
        if (accountId) {
            // Update existing account
            savedAccount = await saveData(`accounts/${accountId}`, accountData, 'PUT');
        } else {
            // Create new account
            savedAccount = await saveData('accounts', accountData);
        }
        
        // Close modal
        const accountModal = document.getElementById('account-modal');
        if (accountModal) {
            accountModal.classList.add('hidden');
            accountModal.style.display = 'none';
        }
        
        // Reload account data
        await loadAccountData();
        
        return savedAccount;
    } catch (error) {
        console.error('Error saving account:', error);
        alert('Error saving account: ' + error.message);
        return null;
    }
}

// Journal Entry Operations
async function saveJournalEntry(status = 'Draft') {
    const entryId = document.getElementById('edit-je-id-input').value;
    const entryData = {
        entry_date: document.getElementById('journal-entry-date').value,
        reference_number: document.getElementById('journal-entry-reference').value,
        description: document.getElementById('journal-entry-description').value,
        is_inter_entity: document.getElementById('journal-entry-is-inter-entity').checked,
        status: status,
        entity_id: appState.selectedEntityId,
        created_by: 'Current User' // This would be replaced with actual user info
    };
    
    try {
        let savedEntry;
        
        if (entryId) {
            // Update existing entry
            savedEntry = await saveData(`journal-entries/${entryId}`, entryData, 'PUT');
        } else {
            // Create new entry
            savedEntry = await saveData('journal-entries', entryData);
        }
        
        // Close modal
        const journalEntryModal = document.getElementById('journal-entry-modal');
        if (journalEntryModal) {
            journalEntryModal.classList.add('hidden');
            journalEntryModal.style.display = 'none';
        }
        
        // Reload journal entry data
        await loadJournalEntryData();
        
        return savedEntry;
    } catch (error) {
        console.error('Error saving journal entry:', error);
        alert('Error saving journal entry: ' + error.message);
        return null;
    }
}

async function postJournalEntry(entryId) {
    if (!confirm('Are you sure you want to post this journal entry? This action cannot be undone.')) {
        return;
    }
    
    try {
        const entry = appState.journalEntries.find(je => je.id === entryId);
        if (!entry) {
            throw new Error('Journal entry not found');
        }
        
        // Update entry status to Posted
        const updatedEntry = { ...entry, status: 'Posted' };
        await saveData(`journal-entries/${entryId}`, updatedEntry, 'PUT');
        
        // Reload journal entry data
        await loadJournalEntryData();
        
        alert('Journal entry posted successfully.');
    } catch (error) {
        console.error('Error posting journal entry:', error);
        alert('Error posting journal entry: ' + error.message);
    }
}

// Delete Journal Entry
async function deleteJournalEntry(entryId) {
    if (!entryId) return;
    if (!confirm('Are you sure you want to delete this journal entry? This action cannot be undone.')) return;

    try {
        const response = await fetch(`/api/journal-entries/${entryId}`, { method: 'DELETE' });
        if (!response.ok) {
            let msg = `API Error: ${response.status}`;
            try {
                const data = await response.json();
                if (data && data.message) msg = data.message;
            } catch {/* ignore */}
            throw new Error(msg);
        }
        await loadJournalEntryData();
        alert('Journal entry deleted successfully.');
    } catch (err) {
        console.error('Error deleting journal entry:', err);
        alert('Error deleting journal entry: ' + err.message);
    }
}

// ===================================================================
// FUND REPORTING FUNCTIONS
// ===================================================================

function populateFundReportsDropdown() {
    const fundSelect = document.getElementById('fund-reports-fund-select');
    if (!fundSelect) return;

    fundSelect.innerHTML = '<option value="">Select a Fund...</option>';
    
    // Sort funds alphabetically by name
    const sortedFunds = [...appState.funds].sort((a,b) => a.name.localeCompare(b.name));
    
    sortedFunds.forEach(fund => {
        const option = document.createElement('option');
        option.value = fund.id;
        option.textContent = `${fund.name} (${fund.code})`;
        fundSelect.appendChild(option);
    });
}

async function generateFundReport() {
    const activeTab = document.querySelector('#fund-reports-page .tab-item.active').dataset.tab;
    
    switch(activeTab) {
        case 'fund-balance-report':
            await generateFundBalanceReport();
            break;
        case 'fund-activity-report':
            await generateFundActivityReport();
            break;
        case 'fund-statement-report':
            await generateFundStatementReport();
            break;
        case 'funds-comparison-report':
            await generateFundsComparisonReport();
            break;
    }
}

async function generateFundBalanceReport() {
    const fundId   = document.getElementById('fund-reports-fund-select').value;
    const content  = document.getElementById('fund-balance-content');

    /* ------------------------------------------------------------------
     * Basic validation – ensure a fund is chosen
     * ------------------------------------------------------------------ */
    if (!fundId) {
        content.innerHTML =
            '<p class="error">Please select a fund to generate the report.</p>';
        return;
    }

    /* ------------------------------------------------------------------
     * Find the fund in the already-loaded list
     * ------------------------------------------------------------------ */
    const fund = appState.funds.find(f => f.id === fundId);
    if (!fund) {
        content.innerHTML = '<p class="error">Fund not found.</p>';
        return;
    }

    /* ------------------------------------------------------------------
     * Use the fund's balance field that was loaded with /api/funds
     * ------------------------------------------------------------------ */
    try {
        const fundBalance = parseFloat(fund.balance || 0);

        content.innerHTML = `
            <h4>Balance for ${fund.name} (${fund.code})</h4>
            <table class="data-table">
                <thead>
                    <tr><th>Metric</th><th>Amount</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Current Fund Balance</strong></td>
                        <td><strong>${formatCurrency(fundBalance)}</strong></td>
                    </tr>
                    <tr><td>Fund Type</td><td>${fund.type || 'Not specified'}</td></tr>
                    <tr><td>Status</td><td>${fund.status || 'Active'}</td></tr>
                    <tr><td>Description</td><td>${fund.description || 'No description'}</td></tr>
                </tbody>
            </table>
            <p><em>Note: Balance shown is taken from the fund record currently loaded in the application.</em></p>
        `;
    } catch (err) {
        content.innerHTML = `<p class="error">Error generating report: ${err.message}</p>`;
    }
}

async function generateFundActivityReport() {
    const fundId     = document.getElementById('fund-reports-fund-select').value;
    const startDate  = document.getElementById('fund-reports-date-start').value;
    const endDate    = document.getElementById('fund-reports-date-end').value;
    const contentDiv = document.getElementById('fund-activity-content');

    /* ------------------------------------------------------------------
     * Validation
     * ------------------------------------------------------------------ */
    if (!fundId) {
        contentDiv.innerHTML =
            '<p class="error">Please select a fund to generate the report.</p>';
        return;
    }

    /* ------------------------------------------------------------------
     * Locate the fund locally
     * ------------------------------------------------------------------ */
    const fund = appState.funds.find(f => f.id === fundId);
    if (!fund) {
        contentDiv.innerHTML = '<p class="error">Fund not found.</p>';
        return;
    }

    /* ------------------------------------------------------------------
     * Filter journal entries by date range (local data)
     * NOTE: Demo-level – uses journalEntries header info, not per-line fund
     * ------------------------------------------------------------------ */
    try {
        contentDiv.innerHTML = '<p>Loading report...</p>';

        let relevantEntries = appState.journalEntries.filter(entry => {
            const d = new Date(entry.entry_date);
            if (startDate && d < new Date(startDate)) return false;
            if (endDate   && d > new Date(endDate))   return false;
            return true;
        });

        // Sort newest first
        relevantEntries.sort((a, b) =>
            new Date(b.entry_date) - new Date(a.entry_date)
        );

        /* ----------  Render results ---------- */
        if (relevantEntries.length === 0) {
            contentDiv.innerHTML = `
                <h4>Activity for ${fund.name} (${fund.code})</h4>
                <p>No transactions found for the selected date range.</p>
                <p><em>Date range: ${startDate || 'Beginning'} ➜ ${endDate || 'Now'}</em></p>
            `;
            return;
        }

        let html = `
            <h4>Activity for ${fund.name} (${fund.code})</h4>
            <p><em>Date range: ${startDate || 'Beginning'} ➜ ${endDate || 'Now'} • ${relevantEntries.length} journal entries</em></p>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Reference</th>
                        <th>Description</th>
                        <th>Amount</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
        `;

        relevantEntries.forEach(e => {
            html += `
                <tr>
                    <td>${formatDate(e.entry_date)}</td>
                    <td>${e.reference_number || 'N/A'}</td>
                    <td>${e.description || 'N/A'}</td>
                    <td>${formatCurrency(e.total_amount)}</td>
                    <td><span class="status status-${e.status.toLowerCase()}">${e.status}</span></td>
                </tr>
            `;
        });

        html += `
                </tbody>
            </table>
            <p><em>Demo Note: This lists journal entries only. Full implementation would drill into individual fund-specific lines.</em></p>
        `;

        contentDiv.innerHTML = html;

    } catch (err) {
        contentDiv.innerHTML =
            `<p class="error">Error generating report: ${err.message}</p>`;
    }
}

async function generateFundStatementReport() {
    const fundId = document.getElementById('fund-reports-fund-select').value;
    const contentDiv = document.getElementById('fund-statement-content');

    if (!fundId) {
        contentDiv.innerHTML = '<p class="error">Please select a fund to generate the report.</p>';
        return;
    }

    try {
        contentDiv.innerHTML = '<p>Loading report...</p>';
        const data = await fetchData(`reports/fund-statement/${fundId}`);
        
        let revenue = 0;
        let expense = 0;
        
        let tableHTML = `
            <table class="data-table">
                <thead>
                    <tr><th>Account Type</th><th>Net Amount</th></tr>
                </thead>
                <tbody>
        `;

        data.forEach(item => {
            if (item.account_type === 'Revenue') revenue += parseFloat(item.net);
            if (item.account_type === 'Expense') expense += parseFloat(item.net);
            
            tableHTML += `
                <tr>
                    <td>${item.account_type}</td>
                    <td>${formatCurrency(item.net)}</td>
                </tr>
            `;
        });

        const netIncome = revenue + expense; // Expenses are negative, so we add

        tableHTML += `
                </tbody>
                <tfoot>
                    <tr><td><strong>Total Revenue</strong></td><td><strong>${formatCurrency(revenue)}</strong></td></tr>
                    <tr><td><strong>Total Expenses</strong></td><td><strong>${formatCurrency(expense)}</strong></td></tr>
                    <tr><td><strong>Net Income/Loss</strong></td><td><strong>${formatCurrency(netIncome)}</strong></td></tr>
                </tfoot>
            </table>
        `;
        contentDiv.innerHTML = tableHTML;

    } catch (error) {
        contentDiv.innerHTML = `<p class="error">Error generating report: ${error.message}</p>`;
    }
}

async function generateFundsComparisonReport() {
    const contentDiv = document.getElementById('funds-comparison-content');
    try {
        contentDiv.innerHTML = '<p>Loading report...</p>';
        const data = await fetchData('reports/funds-comparison');

        if (data.length === 0) {
            contentDiv.innerHTML = '<p>No funds found to compare.</p>';
            return;
        }

        let tableHTML = `
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Fund Name</th>
                        <th>Fund Code</th>
                        <th>Balance</th>
                    </tr>
                </thead>
                <tbody>
        `;
        data.forEach(fund => {
            tableHTML += `
                <tr>
                    <td>${fund.name}</td>
                    <td>${fund.code}</td>
                    <td>${formatCurrency(fund.balance)}</td>
                </tr>
            `;
        });
        tableHTML += `</tbody></table>`;
        contentDiv.innerHTML = tableHTML;

    } catch (error) {
        contentDiv.innerHTML = `<p class="error">Error generating report: ${error.message}</p>`;
    }
}

// Documentation Page Functions
async function loadDocumentationPage() {
    console.log('Loading documentation page...');
    const documentGrid = document.getElementById('document-grid');
    
    try {
        // Show loading message
        documentGrid.innerHTML = '<div class="loading-message">Loading documentation...</div>';
        
        // Fetch documents from API
        const response = await fetch('/api/documents');
        const result = await response.json();
        
        if (result.success && result.documents.length > 0) {
            renderDocuments(result.documents, result.count);
        } else {
            documentGrid.innerHTML = '<div class="no-documents">No documentation files found.</div>';
        }
    } catch (error) {
        console.error('Error loading documentation:', error);
        documentGrid.innerHTML = '<div class="no-documents">Error loading documentation files.</div>';
    }
}

function renderDocuments(documents, count) {
    const documentGrid = document.getElementById('document-grid');
    
    // Add stats header
    const statsHTML = `
        <div class="document-stats">
            <p class="document-stats-text">Found ${count} documentation file${count !== 1 ? 's' : ''}</p>
        </div>
    `;
    
    // Generate document cards
    const documentsHTML = documents.map(doc => {
        const sizeKB = Math.round(doc.size / 1024);
        const lastModified = formatDate(doc.lastModified);
        
        // Get description based on document type
        const description = getDocumentDescription(doc.filename);
        
        return `
            <div class="document-card" onclick="openDocument('${doc.url